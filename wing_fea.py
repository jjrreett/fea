from utils import stack_faces_2d
import numpy as np
import pickle
import pyvista as pv
import triangle as tr

from units import *
from naca_airfoil import naca_points
import matplotlib.pyplot as plt

import rich

cord = 5.6 * ft
vertices, t = naca_points(100, 0.4, 0.04, 0.12, return_t_points=True)
vertices *= cord


def get_cp_data():
    """Generated by xfoil"""
    with open("cp_data.txt", "r") as f:
        data = np.loadtxt(f, skiprows=3)

    # Extract coordinates and cp data
    vertices = data[:, 0:2]
    cp_data = data[:, 2]

    distance_between_vertices = np.sqrt(np.sum(np.diff(vertices, axis=0) ** 2, axis=1))

    dist = np.cumsum(distance_between_vertices)
    dist = np.insert(dist, 0, 0)

    dist = dist / np.max(dist)

    return vertices, dist, cp_data


cp_polar_cords, cp_polar_t, cp = get_cp_data()
cp = np.interp(t, cp_polar_t, cp)


segments = [(i, i + 1) for i in range(len(vertices) - 1)]
segments.append((len(vertices) - 1, 0))  # Close the loop
segments = np.array(segments)

cp_segments = np.mean(cp[segments], axis=1)

# Compute the linear distance for each segment
segment_lengths = np.linalg.norm(np.diff(vertices[segments], axis=1).squeeze(), axis=1)
mean_segment_length = np.mean(segment_lengths)
force_per_segment = np.zeros(shape=(segments.shape[0], 2))
forces = np.zeros_like(vertices)
# Decompose forces into the force data structure by vertex
for i, segment in enumerate(segments):
    v0, v1 = vertices[segment]

    direction = v1 - v0
    normal = np.array([-direction[1], direction[0]])
    normal = normal / np.linalg.norm(normal)

    force_vector = normal * cp_segments[i] * segment_lengths[i]
    force_per_segment[i] = force_vector

    forces[segment[0]] += force_vector / 2
    forces[segment[1]] += force_vector / 2
# print(force_per_segment)


# Plot each segment with the color from cp_segments
color_bounds = (-max(abs(cp_segments)), max(abs(cp_segments)))
for i, segment in enumerate(segments):
    plt.plot(
        vertices[segment, 0],
        vertices[segment, 1],
        color=plt.cm.coolwarm(
            (cp_segments[i] - color_bounds[0] / (color_bounds[1] - color_bounds[0]))
        ),
        linewidth=2,
    )

# Add color bar
sm = plt.cm.ScalarMappable(
    cmap="coolwarm", norm=plt.Normalize(vmin=color_bounds[0], vmax=color_bounds[1])
)
plt.colorbar(sm, ax=plt.gca(), label="Cp")

# Set labels and title
plt.xlabel("X Coordinate")
plt.ylabel("Y Coordinate")
plt.title("Cp Data Segment Plot")
plt.axis("equal")

# Compute the normal vector for each segment and plot it
for i, vertex in enumerate(vertices):
    center = vertex
    f = forces[i]

    # Plot the normal vector
    plt.quiver(
        center[0],
        center[1],
        f[0],
        f[1],
        angles="xy",
        scale_units="xy",
        scale=1,
        color=plt.cm.coolwarm(
            (cp_segments[i] - min(cp_segments)) / (max(cp_segments) - min(cp_segments))
        ),
    )

# plt.show()

# TODO make force data per segment. then when stacking segments, turn force data per surface quad. to be resolved into node forces


def circle(N, R, x=0, y=0):
    i = np.arange(N)
    theta = i * 2 * np.pi / N
    pts = np.stack([np.cos(theta), np.sin(theta)], axis=1) * R
    pts[:, 0] += x  # Adjust x coordinates
    pts[:, 1] += y  # Adjust y coordinates
    seg = np.stack([i, (i + 1) % N], axis=1)
    return pts, seg


r = 2 * inch
circumference = 2 * np.pi * r
n_points = int(np.ceil(circumference / mean_segment_length))
pts0, seg0 = circle(n_points, 2 * inch, x=10 * inch, y=1.26 * inch)

mean_element_area = np.mean(segment_lengths) * np.mean(segment_lengths) / 2 * 1.5
# print(f"{mean_element_area}")
vertices = np.vstack([vertices, pts0])
segments = np.vstack([segments, seg0 + segments.shape[0]])


A = {
    "vertices": vertices,
    "segments": segments,
    "holes": np.array([[10 * inch, 1.26 * inch]]),
}

# rich.print(A)
B = tr.triangulate(A, f"qpa{mean_element_area}")
# rich.print(B)

# tr.plot(plt.gca(), **B)
# plt.show()

# exit()


nodes, elements = stack_faces_2d(
    B["vertices"],
    B["triangles"],
    np.linspace(0, 1, 2),
    segments=B["segments"],
)
print("nodes", nodes, sep="\n")
print("elements", elements, sep="\n")


plotter = pv.Plotter()
num_elements = elements.shape[0]
cells = np.zeros((num_elements, 7), dtype=np.int32)
cells[:, 0] = 6
cells[:, 1:] = elements
cells = cells.flatten()
grid = pv.UnstructuredGrid(
    cells, pv.CellType.WEDGE * np.ones((num_elements,)), nodes.flatten()
)
plotter.add_mesh(grid, show_edges=True)

plotter.show()

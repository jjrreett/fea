# %%
# from utils import stack_faces_2d
import numpy as np
import pickle
import pyvista as pv
import triangle as tr

from units import *
from utils import *
from naca_airfoil import naca_points
import matplotlib.pyplot as plt

import rich
# %%

cord = 5.6 * ft
velocity = 55 * knot
density = 1.225 * kg / m**3
dynamic_pressure = 0.5 * density * velocity**2
# %%
# Generate a set of evenly spaced samples of the naca airfoil
airfoil_vertices, t = naca_points(100, 0.4, 0.04, 0.12, return_t_points=True)
airfoil_vertices *= cord
airfoil_vertices

# %%
# Get the cp data off disk from xfoil
"""Generated by xfoil"""
with open("cp_data.txt", "r") as f:
    data = np.loadtxt(f, skiprows=3)

# Extract coordinates and cp data
cp_polar_cords = data[:, 0:2]
cp_data = data[:, 2]

distance_between_vertices = np.sqrt(
    np.sum(np.diff(cp_polar_cords, axis=0) ** 2, axis=1)
)

cp_polar_t = np.cumsum(distance_between_vertices)
cp_polar_t = np.insert(cp_polar_t, 0, 0)

cp_polar_t = cp_polar_t / np.max(cp_polar_t)

# resample cp on generated airfoil coords
cp = np.interp(t, cp_polar_t, cp_data)
cp
# %%
# Turn the airfoil points to a set of segments for mesh generation

airfoil_segments = [(i, i + 1) for i in range(len(airfoil_vertices) - 1)]
airfoil_segments.append((len(airfoil_vertices) - 1, 0))  # Close the loop
airfoil_segments = np.array(airfoil_segments)
airfoil_segments

# %%
# Turn the cp values into a force vector per segment
cp_segments = np.mean(cp[airfoil_segments], axis=1)

# Compute the linear distance for each segment
segment_lengths = np.linalg.norm(
    np.diff(airfoil_vertices[airfoil_segments], axis=1).squeeze(), axis=1
)
mean_segment_length = np.mean(segment_lengths)
force_per_segment = np.zeros(shape=(airfoil_segments.shape[0], 2))
forces = np.zeros_like(airfoil_vertices)
# Decompose forces into the force data structure by vertex
for i, segment in enumerate(airfoil_segments):
    v0, v1 = airfoil_vertices[segment]

    direction = v1 - v0
    normal = np.array([-direction[1], direction[0]])
    normal = normal / np.linalg.norm(normal)

    force_vector = normal * cp_segments[i] * dynamic_pressure
    force_per_segment[i] = force_vector

force_per_segment
# %%

# Plot each segment with the color from cp_segments
color_bounds = (-max(abs(cp_segments)), max(abs(cp_segments)))
sm = plt.cm.ScalarMappable(
    cmap="coolwarm", norm=plt.Normalize(vmin=color_bounds[0], vmax=color_bounds[1])
)
plt.colorbar(sm, ax=plt.gca(), label="Cp")
plt.xlabel("X Coordinate")
plt.ylabel("Y Coordinate")
plt.title("Cp Data Segment Plot")
plt.axis("equal")

plt.plot(airfoil_vertices[:, 0], airfoil_vertices[:, 1])

# Compute the normal vector for each segment and plot it
for segment, force in zip(airfoil_segments, force_per_segment):
    # print(airfoil_vertices[segment])
    center = np.sum(airfoil_vertices[segment], axis=0) / 2

    # Plot the normal vector
    plt.quiver(
        center[0],
        center[1],
        force[0],
        force[1],
        angles="xy",
        scale_units="xy",
        scale=1,
        color=plt.cm.coolwarm(
            (cp_segments[i] - color_bounds[0]) / (color_bounds[1] - color_bounds[0])
        ),
    )


# Add cutout for spar
spar_center = np.array([10 * inch, 1.26 * inch])
spar_radius = 2 * inch
circumference = 2 * np.pi * spar_radius
n_points = int(np.ceil(circumference / mean_segment_length))
spar_cutout_vertices, spar_cutout_segments = circle(
    n_points, spar_radius, x=spar_center[0], y=spar_center[1]
)
plt.plot(spar_cutout_vertices[:, 0], spar_cutout_vertices[:, 1])
# plt.show()

# %%
mean_element_area = np.mean(segment_lengths) * np.mean(segment_lengths) / 2 * 1.5

spar_cutout_segments = spar_cutout_segments + airfoil_segments.shape[0]
A = {
    "vertices": np.vstack([airfoil_vertices, spar_cutout_vertices]),
    "segments": np.vstack([airfoil_segments, spar_cutout_segments]),
    "holes": np.array(
        [
            spar_center,
        ]
    ),
}

# rich.print(A)
B = tr.triangulate(A, f"qpa{mean_element_area}")
# rich.print(B)

tr.plot(plt.gca(), **B)
# plt.show()

# exit()

# %%
n_layers = 10
n_nodes_in_layer = B["vertices"].shape[0]
z_heights = np.linspace(0, 1, n_layers + 1)
nodes = stack_nodes(B["vertices"], z_heights)
elements = stack_index_array(B["triangles"], n_layers, n_nodes_in_layer)
airfoil_surfaces = stack_index_array(airfoil_segments, n_layers, n_nodes_in_layer)
airfoil_forces = np.tile(force_per_segment, (n_layers, 1))
airfoil_forces = np.hstack([airfoil_forces, np.zeros((airfoil_forces.shape[0], 1))])
spar_surfaces = stack_index_array(spar_cutout_segments, n_layers, n_nodes_in_layer)
spar_nodes = np.unique(spar_surfaces)
for i, s in enumerate(airfoil_surfaces):
    # Compute the area of the 4 point surface
    v0, v1, v2, v3 = nodes[s[:4]]
    area = 0.5 * np.linalg.norm(np.cross(v1 - v0, v2 - v0)) + 0.5 * np.linalg.norm(
        np.cross(v2 - v0, v3 - v0)
    )
    airfoil_forces[i] *= area
print("nodes", nodes.shape, nodes, sep="\n")
print("elements", elements.shape, elements, sep="\n")
print("airfoil_surfaces", airfoil_surfaces.shape, airfoil_surfaces, sep="\n")
print("airfoil_forces", airfoil_forces.shape, airfoil_forces, sep="\n")
total_force = np.sum(airfoil_forces, axis=0)
print("total_force", total_force / lbf, sep="\n")
# %%

plotter = pv.Plotter()
num_elements = elements.shape[0]
cells = np.zeros((num_elements, 7), dtype=np.int32)
cells[:, 0] = 6
cells[:, 1:] = elements
cells = cells.flatten()
grid = pv.UnstructuredGrid(
    cells, pv.CellType.WEDGE * np.ones((num_elements,)), nodes.flatten()
)
plotter.add_mesh(grid, show_edges=True)

num_elements = airfoil_surfaces.shape[0]
cells = np.zeros((num_elements, 5), dtype=np.int32)
cells[:, 0] = 4
cells[:, 1:] = airfoil_surfaces
surface = pv.UnstructuredGrid(
    cells, pv.CellType.PIXEL * np.ones((num_elements,)), nodes.flatten()
)
# plotter.add_mesh(surface, show_edges=True)

# Decompose the forces into the nodes
node_forces = np.zeros_like(nodes)
for i, surface in enumerate(airfoil_surfaces):
    for node in surface:
        node_forces[node] += airfoil_forces[i] / 4

# Add force vectors to the plot
plotter.add_arrows(
    nodes, node_forces, color="red", mag=0.1 / max(np.linalg.norm(node_forces, axis=1))
)


# %%
constraints = np.zeros(nodes.shape, dtype=int)
constraints[spar_nodes] = np.array([1, 1, 1])

# forces = np.zeros(nodes.shape, dtype=float)
# front_nodes = np.where(nodes[:, 1] == 0)[0]
# forces[front_nodes] += np.array([0, force_per_element, 0])
displacements, forces, strains, stresses, von_mises = solve_wedge(
    nodes, elements, constraints, forces, 3000 * 1e6, 0.0
)

displaced_nodes = nodes + displacements * 100

print("forces", forces / lbf, sep="\n")
print("displacements", displacements / inch, sep="\n")
print("strains", strains[0], sep="\n")
print("stresses", stresses[0], sep="\n")
print("von_mises", von_mises[0], sep="\n")


plotter = pv.Plotter()
cells = np.zeros((num_elements, 7), dtype=np.int32)
cells[:, 0] = 6
cells[:, 1:] = elements
cells = cells.flatten()
grid = pv.UnstructuredGrid(
    cells, pv.CellType.WEDGE * np.ones((num_elements,)), displaced_nodes.flatten()
)
norm = plt.Normalize(stresses.min(), stresses.max())
cmap = plt.get_cmap("viridis")
colors = cmap(norm(stresses))[:, :3]  # Get RGB values
grid.cell_data["colors"] = colors
plotter.add_mesh(grid, show_edges=True, rgb=True, scalars="colrs")

plotter.show()

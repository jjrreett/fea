import numpy as np
import pyvista as pv
import triangle as tr
import numpy.typing as npt
from naca_airfoil import naca_points
import matplotlib.pyplot as plt

from lib.geometry import circle


def vertices_2d_to_3d(vertices: npt.NDArray) -> npt.NDArray:
    return np.hstack((vertices, np.zeros((len(vertices), 1))))


def flatten_elements(elements):
    return [[len(e)] + list(e) for e in elements]


def unflatten_elements(elements):
    segments = []
    idx = 0
    while idx < len(elements):
        length = elements[idx]
        segments.append(elements[idx + 1 : idx + 1 + length])
        idx += length + 1
    return segments

    # def create_grid_from_poly_data(points, lines=None, faces=None):
    grid = pv.PolyData()
    grid.points = points
    if lines is not None:
        if not all(isinstance(i, int) for i in lines):
            lines = flatten_elements(lines)
        grid.lines = lines
    if faces is not None:
        if not all(isinstance(i, int) for i in faces):
            faces = flatten_elements(faces)
        grid.faces = faces
    return grid.cast_to_unstructured_grid()


def layer_poly_data(poly_data, z_heights):
    polys = []

    # Stack nodes in the z direction
    for z in z_heights:
        poly = poly_data.copy()
        poly.points[:, 2] = z
        polys.append(poly)
    return polys


def extrude_poly_data(poly_data, z_heights):
    elements = []
    nodes_per_layer = len(poly_data.points)

    nodes = np.copy(poly_data.points)
    nodes[:, 2] = z_heights[0]

    # cell_data = {key: [] for key in poly_data.cell_data.keys()}

    for i in range(len(z_heights) - 1):
        z1, z2 = z_heights[i], z_heights[i + 1]
        nodes1 = np.copy(poly_data.points)
        nodes1[:, 2] = z1
        nodes2 = np.copy(poly_data.points)
        nodes2[:, 2] = z2

        nodes = np.vstack((nodes, nodes2))

        lines = unflatten_elements(poly_data.lines)
        for line in lines:
            if len(line) == 2:
                type_ = pv.CellType.PIXEL
            else:
                raise NotImplementedError(
                    "Only 2-node lines are supported"
                )  # TODO support multi node lines
            assert len(line) == 2, "Only 2-node lines are supported"
            elements.append(
                (
                    type_,
                    [n + i * nodes_per_layer for n in line]
                    + [n + (i + 1) * nodes_per_layer for n in line],
                )
            )

        faces = unflatten_elements(poly_data.faces)
        for face in faces:
            if len(face) == 3:
                type_ = pv.CellType.WEDGE
            elif len(face) == 4:
                type_ = pv.CellType.HEXAHEDRON
            else:
                type_ = pv.CellType.POLYHEDRON
            elements.append(
                (
                    type_,
                    [n + i * nodes_per_layer for n in face]
                    + [n + (i + 1) * nodes_per_layer for n in face],
                )
            )

        # for key, data in poly_data.cell_data.items():
        #     cell_data[key].extend(data)

    element_types = [e[0] for e in elements]
    elements = [e[1] for e in elements]
    grid = pv.UnstructuredGrid(flatten_elements(elements), element_types, nodes)

    for key, data in poly_data.cell_data.items():
        grid.cell_data[key] = np.tile(data, len(z_heights) - 1)

    return grid


def rotation_matrix2d(angle, degrees=True):
    if degrees:
        angle = np.radians(angle)
    return np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])


# # Add airfoil part
cord = 5.6 * 12
airfoil_vertices, t = naca_points(101, 0.4, 0.04, 0.12, return_t_points=True)
airfoil_vertices -= np.array([[0.25, 0]])
airfoil_vertices = (rotation_matrix2d(-10) @ airfoil_vertices.T).T
airfoil_vertices = vertices_2d_to_3d(airfoil_vertices)
airfoil_vertices *= cord
airfoil_segments = [(i, i + 1) for i in range(len(airfoil_vertices) - 1)]
airfoil_segments.append((len(airfoil_vertices) - 1, 0))  # Close the loop

segment_lengths = np.linalg.norm(
    np.diff(airfoil_vertices[airfoil_segments], axis=1).squeeze(), axis=1
)
print("segment_lengths", segment_lengths.shape, "\n", segment_lengths)
mean_segment_length = np.mean(segment_lengths)
mean_element_area = mean_segment_length**2 / 2 * 1.5


def get_cp_data():
    """Generated by xfoil"""
    with open("cp_data.txt", "r") as f:
        data = np.loadtxt(f, skiprows=3)

    # Extract coordinates and cp data
    vertices = data[:, 0:2]
    cp_data = data[:, 2]

    distance_between_vertices = np.sqrt(np.sum(np.diff(vertices, axis=0) ** 2, axis=1))

    dist = np.cumsum(distance_between_vertices)
    dist = np.insert(dist, 0, 0)

    dist = dist / np.max(dist)

    return vertices, dist, cp_data


cp_polar_cords, cp_polar_t, cp = get_cp_data()
cp = np.interp(t, cp_polar_t, cp)

cp_segments = np.mean(cp[airfoil_segments], axis=1)

airfoil = pv.PolyData()
airfoil.points = airfoil_vertices
airfoil.lines = flatten_elements(airfoil_segments)
airfoil.cell_data["cp"] = cp_segments


# Add circle part
r = 2
circumference = 2 * np.pi * r

n_points = int(np.ceil(circumference / mean_segment_length))
circle_vertices, circle_segments = circle(n_points, 2, x=10, y=1.26)
circle_vertices = vertices_2d_to_3d(circle_vertices)

hole = pv.PolyData()
hole.points = circle_vertices
hole.lines = flatten_elements(circle_segments)


combined = airfoil + hole


A = {
    "vertices": combined.points[:, :2],
    "segments": unflatten_elements(combined.lines),
    "holes": np.array([[10, 1.26]]),
}

tr.plot(plt.gca(), **A)
plt.show()

B = tr.triangulate(A, f"qpa{mean_element_area}")
tr.plot(plt.gca(), **B)
plt.show()

triangles = pv.PolyData()
triangles.points = np.hstack((B["vertices"], np.zeros((len(B["vertices"]), 1))))
triangles.faces = [[len(s)] + list(s) for s in B["triangles"]]

cord = pv.PolyData()
cord.points = airfoil_vertices[[0, 51]]
cord.lines = [[2] + [0, 1]]


wing_length = 16 * 12
element_length = 2
num_elements = wing_length // element_length
z_heights = np.linspace(0, 2, 3)
z_heights = np.linspace(0, wing_length, num_elements + 1)

cords = layer_poly_data(cord, z_heights)
airfoil_surface = extrude_poly_data(airfoil, z_heights)
wing_volume = extrude_poly_data(triangles, z_heights)


# plotter = pv.Plotter()
# # plotter.add_mesh(pv.PointSet(points))
# plotter.add_mesh(airfoil)
# plotter.add_mesh(hole)
# plotter.add_mesh(triangles, show_edges=True)
# plotter.add_mesh(cord, color="red")
# for cord in cords:
#     plotter.add_mesh(cord, color="red")
# plotter.add_mesh(wing_volume, show_edges=True, opacity=0.3)
# plotter.add_mesh(
#     airfoil_surface,
#     show_edges=True,
#     scalars="cp",
#     clim=[-np.max(np.abs(cp_segments)), np.max(np.abs(cp_segments))],
# )
# plotter.show()

surface_polydata = airfoil_surface.extract_geometry()

surface_polydata.compute_normals(cell_normals=True, point_normals=False, inplace=True)
normals = surface_polydata.cell_data["Normals"]


# Inspect cell types
cell_types = airfoil_surface.celltypes
unique_cell_types = np.unique(cell_types)
print(f"Unique Cell Types: {unique_cell_types}")

# Check connectivity of a few cells
for i in range(5):  # Example: inspect first 5 cells
    print(f"Cell {i} Connectivity: {airfoil_surface.get_cell(i)}")


# Constants
rho_kg_m3 = 1.225  # Air density in kg/m³
rho_lb_ft3 = rho_kg_m3 * 0.062428  # Convert to lb/ft³

V_m_s = 12.8611  # Air velocity in m/s
V_ft_s = V_m_s * 3.28084  # Convert to ft/s

# Dynamic pressure in lb/ft²
q_lb_ft2 = 0.5 * rho_lb_ft3 * V_ft_s**2

# Convert dynamic pressure to PSI
q_psi = q_lb_ft2 / 144  # 1 PSI = 144 lb/ft²

# Output
print(f"Dynamic Pressure (q) in PSI: {q_psi:.4f} PSI")


cp = airfoil_surface.cell_data["cp"]


### Compute cell areas

points = airfoil_surface.points  # Mesh points
connectivity = airfoil_surface.cells.reshape(-1, 5)[:, 1:]  # Cell-to-point connectivity

# Compute areas for each cell
areas = []
for cell in connectivity:
    # Extract vertex positions
    v0, v1, v2, v3 = points[cell]

    # Split quad into two triangles and compute area
    vec1 = v1 - v0
    vec2 = v2 - v0
    tri1_area = 0.5 * np.linalg.norm(np.cross(vec1, vec2))

    vec1 = v2 - v0
    vec2 = v3 - v0
    tri2_area = 0.5 * np.linalg.norm(np.cross(vec1, vec2))

    # Total area of the quad
    areas.append(tri1_area + tri2_area)

areas = np.array(areas)
airfoil_surface.cell_data["Area"] = areas
print("areas", areas.shape, "\n", areas)
###

# airfoil_surface = airfoil_surface.compute_cell_sizes(length=False, volume=False)
# cell_areas = airfoil_surface.cell_data["Area"]
# print("cell_areas", cell_areas.shape, "\n", cell_areas)
# exit()
forces = q_psi * (cp[:, np.newaxis] * areas[:, np.newaxis] * normals)
print("forces", forces.shape, "\n", forces)

lift = np.sum(forces, axis=0)
print("lift", lift, sep="\n")


# Initialize point forces
point_forces = np.zeros((airfoil_surface.n_points, 3))


cells = unflatten_elements(airfoil_surface.cells)
# Distribute cell forces to points
for i in range(airfoil_surface.n_cells):
    cell_points = cells[i]  # Indices of points in the cell
    num_points = len(cell_points)  # Number of points in the cell
    force_per_point = forces[i] / num_points  # Divide force among points

    for p in cell_points:
        point_forces[p] += force_per_point  # Accumulate force at the point

# Add point forces to the dataset for visualization
airfoil_surface.point_data["forces"] = np.linalg.norm(
    point_forces, axis=1
)  # Magnitude of forces
airfoil_surface.point_data["force_vectors"] = point_forces

# Visualize
plotter = pv.Plotter()
plotter.add_mesh(airfoil_surface, scalars="forces", cmap="coolwarm", show_edges=True)
plotter.add_arrows(airfoil_surface.points, point_forces, color="black", mag=1e-1)
plotter.show_grid()
plotter.show()


# class DynamicEnum:
#     def __init__(self):
#         self._values = {}
#         self._counter = 0

#     def add(self, name):
#         if name not in self._values:
#             self._values[name] = self._counter
#             self._counter += 1
#         return self._values[name]

#     def __getitem__(self, name):
#         return self._values[name]


# class MeshComposer:
#     def __init__(self):
#         self.mesh_enums = DynamicEnum()
#         self.grid = pv.UnstructuredGrid()

#     def add_mesh(self, name, grid):
#         value = self.mesh_enums.add(name)
#         grid.cell_data["selection"] = np.full(grid.n_cells, value, dtype=int)
#         self.grid += grid

#     def get_subgrid(self, name):
#         return self.grid.threshold(
#             value=(self.mesh_enums[name], self.mesh_enums[name]),
#             scalars="selection",
#             preference="cell",
#         )


# composer = MeshComposer()

# mesh_elements = DynamicEnum()

# from pyvista import DataSetFilters


# composer.add_mesh("airfoil", airfoil_surface)
# composer.add_mesh("wing", wing_volume)
# # composer.add_mesh()

# # Plot the filtered meshes
# plotter = pv.Plotter()
# plotter.add_mesh(
#     composer.get_subgrid("wing"), color="red", label="wing", show_edges=True
# )
# plotter.add_mesh(
#     composer.get_subgrid("airfoil"),
#     color="blue",
#     label="airfoil",
#     show_edges=True,
# )
# plotter.add_legend()
# plotter.show()
